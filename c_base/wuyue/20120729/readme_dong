						链接
1,符号：  定义，声明 ：只在   全局变量，函数    之间讨论。
2,定义，声明：
			定义：需分配存储空间
			声明：不为之分配存储空间
	定义，声明  的本质区别：是否分配存储空间。
3,全局变量：
			定义：int  a = 100; 编译过程为变量分配空间在 .data 中
			声明：int  a;       声明的目的：告诉编译器 此符号 合法。
4,函数：
			定义：type func(type) {}
			声明：type func(type);

5,多个文件链接时的	规则：

	1,	同一个符号不允许多次定义
即，不能为同一符号分配多个空间，一个变量名只对应一个存储空间，防止应用歧义。

	2,	允许出现，一定义，多声明。

	3,	只有声明，没有定义时：
			全局变量：将其中一个声明提升为定义，当作未初始化全局变量，保存在		.bss段中，当运行时才分配空间，不在 ELF中开辟空间
				函数	：只有声明，无定义时，如果不调用，是可以的，如果调用此函		数，则是不行滴。
6,多问件编程的一个例子

	   main.c                                   add.c

	int x = 0x12345678;                         long long x;
	int y = 0x12345678;							//short   x;

	int main(void)                              void add()
	{                                           {
		printf("x = %d, y = %d\n", x, y);				x = 0;
		return 0;
	}											}


	$gcc add.c -c
	$ls
	add.c add.o main.c
	$gcc main.c -c
	$ls
	add.c add.o main.c main.o
	$gcc add.o main.o
	$ls
	add.c add.o main.c main.o a.out
	$./a.out
	x = 0, y = 0
	$

	add.c 在链接之前，add.o中已经将add.c中的c代码转换为了汇编，并编译汇编生成了二进制机器指令。
	add.c 中 声明的 long long x; 告诉编译器说，x 是一个8位的整数，void add()中的 x = 0;将 生成填充等待两个挨着的地址的回填指令 
	movl $0, x
	movl $0, x+4
	x 和 x+4 是不确定的地址，需要链接后的地址回填。
	
	结论：数据类型，大转向小，编译器不管你，
					小转向大，编译器出警告，因为可能覆盖其它变量。
7,隐式声明：
			C99中可，根据函数调用时的参数时的实参类型，推测出函数原型。
			implicit declaration 
			隐式      声明

		结论：很不靠谱

8,模块间函数重名问题：
							多模块时，在函数名前加模块名。如果不够，再加版本号。
						int.c                float.c
						int_add();			 float_add();
	
	模块划分：要干净，最好的划分，理想状态下，多人间不用沟通,拿来就能正常使用。

9,	static    1:

	结论：	static 作用：改变了全局符号的链接属性。     从 Global 到 Local 的链接属性

	全局符号：全局变量，函数。
	链接属性：预编译-->编译-->汇编--->链接
	        *.c --> *.i--->*.s---->*.o---->a.out
			链接属性指链接过程时，用到的标记，使最终生成的可执行程序能看到此全局变量和函数。

	静态全局函数：只有本模块可调用，其它模块，不能调用。
	静态全局变量：只有本模块函数可访问，其它模块不能访问。

	全局变量作用域：仅限于定义它的文件内部。
					从定义处开始，至文件尾结束。
	局部变量作用域：在定义它的复合语句内可见。

	但：可通过 声明 --> 导出作用域

	全局变量，函数来说，链接属性是全局性的 .global
		在链接时，链接属性为 .global 的变量，函数都是可被其它模块(文件)引用的。

10, 公有接口，私有函数。

	add.c

	void print_sum()	公有接口
	{
	}
	static int add()	私有函数
	{
	}
