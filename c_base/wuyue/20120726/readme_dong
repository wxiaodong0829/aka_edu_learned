1, X86汇编格式 MS（Intel） (windows)
               AT&T        (linux)
2, movl $1, %eax ;1号系统调用,调表中_exit
3, int $0x80	 ;把以上指令向内核申请，并运行
4, $echo $?      ; ? 保存最近一次函数调用的函数返回值
5, $objdump -dS app		; S 为大写，反汇编 ，生成app时加上-g参数
6, 寄存器有：eax ebx ecx edx	(这四个用户用) 
			 edi esi			(数组下标寄存器，整型，字符型)
			 ebp				(ebp:base pointer 栈帧基地址寄存器)
			 esp				(esp:stack pointer 栈帧顶地址寄存器)
7, 整型，字符型 数组在内存中均是向大地址方向增长
8, 汇编数据类型 .long 4字节 movl 按4字节赋值 
				.word 2字节 movw 按2字节赋值 
				.byte 1字节 movb 按1字节赋值 
9, x86 体系结构（相同寄存器，相同指令集 即相同体系结构）中简单指令：

	je:相等则跳转		(跳转指令均依靠判断 eflags 中的 ZF位)
	jle:小于等于则跳转
	jmp:无条件跳转
10,寻址方式：
	ADDRESS_OF_OFFSET(%BASE_OF_OFFSET, %INDEX, MULTILIER)
	a(b, c, d)
	a + b + c * d
11,栈帧 frame(帧) 由于它的增长，减缩的方式是 后进先出式的栈的方式，中国人又加了一个栈字，称为栈帧。
	存函数内局部变量，临时值（传的参数，保存的返回地址）
	
	当函数被调用时自动开辟的内存空间

	返回时，开辟的内存空间舍弃，不予处理（录像带法则）

12, C 中传递参数的顺序：从右向左依次压入参数，即依此次序计算
	函数返回值，通过特定寄存器 eax 保存
	c 传递参数 ，用户级程序用：栈帧方式。内核级：还可用 c 中嵌汇编传参

13, 几个 多操作指令 
	
	push 寄存器     ; 1,esp 向下移动   2，存储寄存器数据到esp指向的内存
	pop  寄存器		; 1,取esp指向的地址中的数据到寄存器  2,esp 向上移动 

	call 函数地址  ; 1,保存call的下一条指令的地址到当前esp指向的地址
					 2,跳转到函数地址，即函数入口
	ret			   ; 1,取出call保存在当前esp 指向的地址中的内容
					 2，跳到1中取出的地址处，即call的下条指令处
	leave          ; 1, mov %ebp, %esp  2,pop %ebp
