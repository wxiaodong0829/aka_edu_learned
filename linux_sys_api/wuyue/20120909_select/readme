1, select:		（关注  文件   ）
		原理：让内核帮助用户程序去检测文件是否可用(可读，可写，异常)
		用的场合：使用临时监视器，或循环使用次数较少时，使用，比epoll方便
				  或，高并发，短链接，数据稠密型 的场合，select , epoll都行
		使用主要关注点：
				select()
				FD_族
				三个数组结构：内核维护的文件描述符数组
							  select 维护的传入传出位图集
							  用户维护的client[]新创建的让 select 关心的文件描述符集
				网络应用中的主框架:
					while(1) {
						nready = select(...);

						if (监听文件可用) {
							cfd = accept(...);
							...
							...
							...
						}

						for (i = 0; i < maxi; i++) {/*maxi为client[]最大下标*/
							if (client[i] == -1)/*不被select关心的文件描述符*/
								continue;
							if (此被关心的文件可用) {
								...
								...
								...
							}
						}
					}

2, epoll:		( 关注    事件 )
		原理：让内核帮助用户程序去检测文件是否可用(可读，可写，可执行), 内核建立了一个非临时的监视器文件
		用的场合：长时间使用监视器，高并发，短链接，数据稀疏(此时epoll明显比select更有优势,稠密型，差别不大)
		使用时关注点：
					epoll函数族:
								epoll_create
								epoll_ctl		:维护 类似select维护的传入传出位图集 的 文件关注的  事件
								epoll_wait		:直接传出 发生的事件 所在的文件的 集合,类似select中用户维护的client[],
												 但不必像select 一样，扫描所有关心的文件中是否发生了事件，
												 而是直接给出 发生的事件所在文件描述符的数组
					网络应用中的主框架：
					epoll_create();
					epoll_ctl(添加关注监听套接字的是否可读);
					while (1) {
						nready = epoll_wait(等到的可用的事件所在文件描述符的数组 events[]);

						for (i = 0; i < nready; i++) {
							if (events[i] == 监听套接字) {
								accept(...);
								...
							} else { /* 其它 普通数据 套接字 */
								...
								...
								...
							}
						}

					}

3, 多进程：
			I. 开销较大，编程逻辑简单
			II. 用于需要开辟的进程较少的程序。 
			III. 程序 注意 处理僵尸进程问题

4, 多线程：
			I. 开销较小
			II. 用于 既有IO，又有计算，二者比例差不多时 的并发处理 
			III. 分离新线程， 线程间 同步
			V.   线程池技术
