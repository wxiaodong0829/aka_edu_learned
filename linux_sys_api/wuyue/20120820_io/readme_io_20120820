1, 系统调用 ：
			定义：操作系统提供给上层的一组函数。
			功能：1，申请资源， 访问内核数据结构。

2, 打开文件的作用：缓冲文件内容 ---->  fopen(); 
	struct file{
		文件偏移量;
		文件访问权限;
		文件打开标志;(是否阻塞等)
		内核缓冲区首地址;(4k)
	};

	预读：  每个文件都有一个struct file 中的 指向 内核缓冲区.

	文件打开：建立文件结构，预读数据， 开销是很大的，所以尽量不要频繁打开文件。

	内核：对内存的使用是扣的很细的。

3，图 ：

		磁盘
			内核缓冲区 （当struct file 创建时，即open()时,从磁盘预读到内核缓存区（4k））					内核空间  
		---------------------------------------------------------------------------------------------------------> 级别切换		
				FILE 中的库缓冲区 （当fopen时创建此缓冲区,并从内核缓冲区预读到此库缓冲区）					用户空间
					fread 从库缓冲区读取

					(			图1			)

		磁盘
			内核缓冲区 （当struct file 创建时，即open()时,从磁盘预读到内核缓存区（4k））					内核空间  
		---------------------------------------------------------------------------------------------------------> 级别切换		
				read 从内核缓冲区读取内容	(从用户空间切换到内核空间的方法, fread 中也封装了此函数)		用户空间

					(			图2			)


		scanf	fgetc	fgets	fread ...
		----------------------------------
					|  封装了
					v
				read()

					(			图3			)




		PA程序      fd             struct file					   disk
		------			-------
		|	 | -->  0	| A  |  --->    A ->read_diver()			A
		|	 |		1	| B  |  --->    B							B
		|pcb |			  .
		|----|			  .
						  .

		
		struct file {
			struct operation *op; // read, write, lseek, mmap, close.
			...;
		}
					(			图4		VFS 虚拟文件系统模型	)

	结论：
		1,	不同程序可以用同一个文件描述符，因为文件描述符是PCB维护的数组的数组下标，对应不同的struct file , 图4.
		2,	open 返回此文件地址的数组的下标，而不返回地址，可提高数据的安全性	图4
		3,	编程过程中：优先选择库函数 IO
		4,	图一：系统调用：会发生，权级切换，用户(普通公民) 和 内核(中南海)，切入，切出 都很耗时，因为为了安全.
		5,	图2：库函数：在用户层库缓冲中缓冲数据， 不用频繁地从内核缓冲预读到库缓冲，不用频繁地切入切出内核，节省了切入，切出的时间，比系统调用 IO
		6,	图2：比系统调用的数据搬运次数多.但多一次预读，减少了切换级别的次数。
		7	图2：fread(), 是从 库缓冲中读取，当fread一次的读取量等于 库缓存大小时，则使库缓冲的功能降低到最低，每次读数据，都要从内核缓存区读到库缓存，再读到目的地，使得与系统调用的级别切换次数相同，但搬运次数还比系统调用多一倍，因此：见8：
		8	图1，图2：当一次的数据量较大时，接近库函数的缓存区大小时，系统调用函数要更快。当每次的数据量较小时，库缓存的预读起到作用，即，减少了内核与用户的状态切换。
		9	图1，图2：库函数IO，系统调用IO 的时间 由  切入，切出内核的次数决定。


4,	$time ./a.out  统计程序执行时间

5,	获取已打开的文件大小：len = lseek(fd, 0, SEEK_END);
	off_t lseek(int fd, off_t offset, int wence);
	当打开文件时加上了  O_LARGEFILE 使用大文件，用64位的偏移。（用时，需-DLARGEFILE64_SOURCE）

	可用于扩展文件大小，需要在lseek()后的第一次写之后，文件才会真正扩展。中间的空洞用0填充.

6, 
	$make
	$ls
	$!m    (执行最后一次以m开头的 shell  命令)
	


	
7,		总结：

	概念：
		1，系统调用
		2，文件描述符
		3，隐式回收系统资源
		4，I/O效率对比
		5，文件偏移  以大文件方式，扩展文件大小
